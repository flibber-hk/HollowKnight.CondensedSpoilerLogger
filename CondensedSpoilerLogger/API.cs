using System;
using System.Collections.Generic;
using MonoMod.ModInterop;
using RandomizerMod.Logging;
using Category = CondensedSpoilerLogger.Loggers.CondensedSpoilerLog.Category;

namespace CondensedSpoilerLogger
{
    /// <summary>
    /// Class defining API methods for interacting with the condensed spoiler log.
    /// 
    /// The other logs generated by this mod are typically not affected.
    /// </summary>
    public static class API
    {
        private static Modding.ILogger _logger = new Modding.SimpleLogger("CondensedSpoilerLogger.API");

        [ModExportName(nameof(CondensedSpoilerLogger))]
        internal static class Export
        {
            public static void AddCategory(string categoryName, Func<LogArguments, bool> test, List<string> entries)
                => API.AddCategory(categoryName, test, entries);

            /// <summary>
            /// Add a category to the condensed spoiler log - delegates to AddCategory, but only uses
            /// System types so does not create a run-time Randomizer dependency.
            /// </summary>
            public static void AddCategorySafe(string categoryName, Func<bool> test, List<string> entries)
                => API.AddCategory(categoryName, _ => test(), entries);

            public static void MakeItemMatch(string parent, string child)
                => API.MakeItemMatch(parent, child);
        }

        private static readonly List<Category> AdditionalCategories = new();

        /// <summary>
        /// Add a category to the Condensed Spoiler Log.
        /// </summary>
        /// <param name="categoryName">The title to give the category.</param>
        /// <param name="test">Return false to skip adding this category to the log.</param>
        /// <param name="entries">A list of items to log in the category.</param>
        public static void AddCategory(string categoryName, Func<LogArguments, bool> test, List<string> entries)
        {
            AdditionalCategories.Add(new(categoryName, test, entries));
            _logger.LogDebug($"Received category {categoryName} with up to {entries.Count} distinct entries.");
        }

        internal static IEnumerable<Category> GetAdditionalCategories()
        {
            return AdditionalCategories;
        }

        private static readonly Dictionary<string, List<string>> ItemMatches = new();

        /// <summary>
        /// Declare a relation between two items - whenever the condensed spoiler logger
        /// logs the location(s) of the parent item, it will also log the location(s) of the child item.
        /// 
        /// The condensed spoiler log will distinguish between the parent and child - this method would
        /// make sense for e.g. Mantis Claw and Left Mantis Claw, but not e.g. Mothwing Cloak and
        /// Shade Cloak (which are treated as identical and logged together).
        /// 
        /// Example: MakeItemMatch(ItemNames.Mantis_Claw, ItemNames.Left_Mantis_Claw);
        /// 
        /// The implied tree is processed in BFS order, ignoring repeats.
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="child"></param>
        public static void MakeItemMatch(string parent, string child)
        {
            if (!ItemMatches.TryGetValue(parent, out List<string> children))
            {
                ItemMatches[parent] = children = new();
            }

            if (!children.Contains(child))
            {
                children.Add(child);
            }

            _logger.LogFine($"Received match {parent} --> {child}");
        }

        internal static Dictionary<string, List<string>> GetAdditionalMatches()
        {
            return ItemMatches;
        }
    }
}
